{"pages":[{"title":"关于本站","text":"About Me12345// 想好了再写type Coder struct &#123; name string email string&#125; TODO List存疑的问题，先再此处记录 问题 存疑日期 解决日期 解决方案 Go語言并发入门1 中打印字母表的案例，为什么先打印大写字母而不是先打印小写字母 2019年8月11日 ❌ ❌ 测试 测试 ✅ ✅ 读书列表// TODO: 更新记录 2019年8月10日 周六 开启本博客，使用 Hexo 生成，基于 Minos 主题","link":"/about/index.html"},{"title":"归档","text":"","link":"/achives/index.html"},{"title":"画廊","text":"","link":"/music/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签们","text":"","link":"/tags/index.html"}],"posts":[{"title":"Go語言并发入门1-goroutine","text":"并发与并行进程与线程操作系统是在 物理处理器 上调度线程来执行，而 Go 语言在运行时，会在 逻辑处理器 上调度 goroutine(协程) 来运行，每个逻辑处理器都分别绑定到一个操作系统线程。从 Go 1.5 版本开始，Go 语言默认会为每个可用的物理处理器分配一个逻辑处理器，这些逻辑处理器会用于执行所有被创建的 goroutine。而在 1.5 版本之前，默认给整个应用程序只分配一个逻辑处理器。 如下图所示，一个逻辑处理器（如P0）被绑定到了操作系统线程（M2）上，该逻辑处理器对应一个本地的 运行队列 每一次创建新的 goroutine 都会本分配到运行队列上，二逻辑处理器则是从该队列上调度 goroutine 来执行。 如果运行的 goroutine 需要执行一个阻塞的操作（比如打开文件）时，线程 和 goroutine 会从 逻辑处理器 上分离开（如下图右侧图所示），该线程（M2）会继续阻塞，而此时的调度器会为逻辑处理器创建一个新的 线程 并绑定在该逻辑处理器上，之后，该逻辑处理器可以继续从运行队列中选择 goroutine 来执行。一旦被阻塞的操作执行完成并返回，对应的 goroutine 会被放回到本地运行队列，而之前的线程会被保存好，以便可以继续使用。 调度器对可以创建的逻辑处理器的数量没有限制，但是语言运行时默认限制每个程序最多创建 10 000 个线程（每个逻辑处理器都会绑定一个系统线程，所以创建一个逻辑处理器就需要创建一个系统线程）。该限制可以可以通过调用 runtime/debuger 包中的 SetMaxThreads 方法来设置。 并发和并行的区别并行： 不同的代码同时在 不同的处理器 上执行，需要更多的硬件资源，比如多核处理器 并发： 不同的代码在同 一个处理器 上执行，需要较少的硬件资源，单核处理器就可以处理 Go 语言的设计理念是『使用较少的资源做更多的事』。 当有多个逻辑处理器可以使用时，Go 语言的调度器会将 goroutine 平均分配到每个逻辑处理器，这样 goroutine 就会在不同的线程上执行。 goroutine下面通过一个例子深入理解调度器的行为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"runtime\" \"sync\")// 演示如何创建 goroutine// 以及调度器的行为func main() &#123; // 分配一个逻辑处理器给调度器 // 函数 GOMAXPROCS 允许程序更改调度器可以使用的逻辑处理器的数量 runtime.GOMAXPROCS(1) // wg 用来等待程序完成 // 计数加2，表示等待两个 goroutine var wg sync.WaitGroup wg.Add(2) fmt.Println(\"Start Goroutines\") // 声明一个匿名函数，并创建一个 goroutine go func() &#123; // 在函数退出时调用 Done 来通知 main 函数工作已经完成 defer wg.Done() // 打印字母表 3 次 for count := 0; count &lt; 3; count++ &#123; for char := 'a'; char &lt; 'a'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() fmt.Printf(\"\\n\") // 声明一个匿名函数，并创建第二个 goroutine go func() &#123; // 同上 defer wg.Done() for count := 0; count &lt; 3; count++ &#123; for char := 'A'; char &lt; 'A'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() // 等待 goroutine 结束 fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"\\nTerminating Program\")&#125; 执行结果： 疑问？此处为什么是先打印 大写字母 而不是先打印 小写字母 ？？？ TODO-1: 暂时存疑，后面研究一下单独写一篇博客来记录 此处，书中有一句解释： 这里说的第一个 goroutine 完成时间太短的意识是 大写字母 和 小写字母 没有交叉打印的原因。下面的列子则演示了两个 goroutine 相互交叉打印的情况： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"runtime\" \"sync\")var wg sync.WaitGroupfunc main() &#123; runtime.GOMAXPROCS(1) wg.Add(2) fmt.Println(\"Create Goroutines\") go printPrime(\"A\") go printPrime(\"B\") fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"Terminating Program\")&#125;func printPrime(prefix string) &#123; defer wg.Done()next: for outer := 2; outer &lt; 5000; outer++ &#123; for inner := 2; inner &lt; outer; inner++ &#123; if outer%inner == 0 &#123; continue next &#125; &#125; fmt.Printf(\"%s: %d \\n\", prefix, outer) &#125; fmt.Println(\"Completed\", prefix)&#125;","link":"/2019/08/11/Go語言并发入门1--goroutine/"},{"title":"Hello World","text":"Welcome to my personal blog, have enjoy !测试代码块： 123456789package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"Hello World\")&#125;","link":"/2019/08/10/HelloWorld/"}],"tags":[{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Goroutine","slug":"Goroutine","link":"/tags/Goroutine/"},{"name":"First","slug":"First","link":"/tags/First/"}],"categories":[{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"DEMO","slug":"DEMO","link":"/categories/DEMO/"}]}