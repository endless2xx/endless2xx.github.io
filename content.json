{"pages":[{"title":"关于本站","text":"About Me12345// 想好了再写type Coder struct &#123; name string email string&#125; TODO List存疑的问题，先再此处记录 问题 存档日期 解决日期 解决方案 测试 2019年8月31日 2019年8月31日 ✅测试 更新记录 2019年8月10日 周六 开启本博客，使用 Hexo 生成，基于 Minos 主题","link":"/about/index.html"},{"title":"归档","text":"","link":"/achives/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"画廊","text":"","link":"/music/index.html"},{"title":"标签们","text":"","link":"/tags/index.html"}],"posts":[{"title":"LeetCode848-字母移位","text":"问题描述 『848.字母移位』 查看原题 『中文』 『难度』🟡「Medium」 代码12345678910111213141516171819202122package mainimport \"fmt\"var letters = []byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'&#125;func main() &#123; shifts := []int&#123;3, 5, 9&#125; S := shiftingLetters(\"abc\", shifts) fmt.Println(S)&#125;func shiftingLetters(S string, shifts []int) string &#123; bs := []byte(S) move := 0 for i := len(shifts) - 1; i &gt;= 0; i-- &#123; // 需要移动的位数，因为字母表是循环的，所以对26取模就是移动的次数 move += (shifts[i] % 26) bs[i] = letters[(int(bs[i]-'a')+move)%26] &#125; return string(bs)&#125;","link":"/2019/08/18/LeetCode848-ShiftingLetters/"},{"title":"Hello World","text":"Welcome to my personal blog, have enjoy !测试代码块： 123456789package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"Hello World\")&#125;","link":"/2019/08/10/HelloWorld/"},{"title":"LeetCode1-TwoSum","text":"问题描述『1.两数之和』 查看原题 中文 『难度』🟢「Easy」 思路分析假设遍历数组的第一个元素是2，而 target = 9，所以可以得知另一个值是 9-2 = 7，然后去判断数组中是否有 7 这个元素，以此类推。 代码123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; nums := []int&#123;2, 3, 4&#125; target := 6 result := twoSum(nums, target) fmt.Println(result)&#125;// 计算两数之和func twoSum(nums []int, target int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; // 获得另一个数 another := target - nums[i] for j := i + 1; j &lt; len(nums); j++ &#123; if nums[j] == another &#123; result := []int&#123;i, j&#125; return result &#125; &#125; &#125; return nil&#125;","link":"/2019/08/29/LeetCode1-TwoSum/"},{"title":"Go語言并发入门1-goroutine","text":"并发与并行进程与线程操作系统是在 物理处理器 上调度线程来执行，而 Go 语言在运行时，会在 逻辑处理器 上调度 goroutine(协程) 来运行，每个逻辑处理器都分别绑定到一个操作系统线程。从 Go 1.5 版本开始，Go 语言默认会为每个可用的物理处理器分配一个逻辑处理器，这些逻辑处理器会用于执行所有被创建的 goroutine。而在 1.5 版本之前，默认给整个应用程序只分配一个逻辑处理器。 如下图所示，一个逻辑处理器（如P0）被绑定到了操作系统线程（M2）上，该逻辑处理器对应一个本地的 运行队列 每一次创建新的 goroutine 都会本分配到运行队列上，二逻辑处理器则是从该队列上调度 goroutine 来执行。 如果运行的 goroutine 需要执行一个阻塞的操作（比如打开文件）时，线程 和 goroutine 会从 逻辑处理器 上分离开（如下图右侧图所示），该线程（M2）会继续阻塞，而此时的调度器会为逻辑处理器创建一个新的 线程 并绑定在该逻辑处理器上，之后，该逻辑处理器可以继续从运行队列中选择 goroutine 来执行。一旦被阻塞的操作执行完成并返回，对应的 goroutine 会被放回到本地运行队列，而之前的线程会被保存好，以便可以继续使用。 调度器对可以创建的逻辑处理器的数量没有限制，但是语言运行时默认限制每个程序最多创建 10 000 个线程（每个逻辑处理器都会绑定一个系统线程，所以创建一个逻辑处理器就需要创建一个系统线程）。该限制可以可以通过调用 runtime/debuger 包中的 SetMaxThreads 方法来设置。 并发和并行的区别并行： 不同的代码同时在 不同的处理器 上执行，需要更多的硬件资源，比如多核处理器 并发： 不同的代码在同 一个处理器 上执行，需要较少的硬件资源，单核处理器就可以处理 Go 语言的设计理念是『使用较少的资源做更多的事』。 当有多个逻辑处理器可以使用时，Go 语言的调度器会将 goroutine 平均分配到每个逻辑处理器，这样 goroutine 就会在不同的线程上执行。 goroutine下面通过一个例子深入理解调度器的行为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"runtime\" \"sync\")// 演示如何创建 goroutine// 以及调度器的行为func main() &#123; // 分配一个逻辑处理器给调度器 // 函数 GOMAXPROCS 允许程序更改调度器可以使用的逻辑处理器的数量 runtime.GOMAXPROCS(1) // wg 用来等待程序完成 // 计数加2，表示等待两个 goroutine var wg sync.WaitGroup wg.Add(2) fmt.Println(\"Start Goroutines\") // 声明一个匿名函数，并创建一个 goroutine go func() &#123; // 在函数退出时调用 Done 来通知 main 函数工作已经完成 defer wg.Done() // 打印字母表 3 次 for count := 0; count &lt; 3; count++ &#123; for char := 'a'; char &lt; 'a'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() fmt.Printf(\"\\n\") // 声明一个匿名函数，并创建第二个 goroutine go func() &#123; // 同上 defer wg.Done() for count := 0; count &lt; 3; count++ &#123; for char := 'A'; char &lt; 'A'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() // 等待 goroutine 结束 fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"\\nTerminating Program\")&#125; 执行结果： 疑问？此处为什么是先打印 大写字母 而不是先打印 小写字母 ？？？ TODO-1: 暂时存疑，后面研究一下单独写一篇博客来记录 此处，书中有一句解释： 这里说的第一个 goroutine 完成时间太短的意识是 大写字母 和 小写字母 没有交叉打印的原因。下面的列子则演示了两个 goroutine 相互交叉打印的情况： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"runtime\" \"sync\")var wg sync.WaitGroupfunc main() &#123; runtime.GOMAXPROCS(1) wg.Add(2) fmt.Println(\"Create Goroutines\") go printPrime(\"A\") go printPrime(\"B\") fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"Terminating Program\")&#125;func printPrime(prefix string) &#123; defer wg.Done()next: for outer := 2; outer &lt; 5000; outer++ &#123; for inner := 2; inner &lt; outer; inner++ &#123; if outer%inner == 0 &#123; continue next &#125; &#125; fmt.Printf(\"%s: %d \\n\", prefix, outer) &#125; fmt.Println(\"Completed\", prefix)&#125;","link":"/2019/08/11/Go語言并发入门1--goroutine/"},{"title":"LeetCode2-AddTwoNumbers","text":"问题描述『2.两数相加』 查看原题 中文 『难度』🟡「Medium」 思路分析错误的思路本人一开始的想法就是将两个链表都转换成数字，然后将两个数字相加，再将得到的和转换成链表。这样的想法是不周全的，没有考虑到如果链表特别的长，数值会越界的情况，如下图，这是本人第一次提交的结果，可以看到输入的第一个链表特别长，所以计算的时候数值越界出现错误的结果 正确的思路首先，请注意，链表中的元素从左到右是从 个位数 到 高位数 递增的，及第一个数是个位数，所以应该是遍历链表，将两个同一位上的数值相加，如果有进位记录下来，还需要考虑两个链表不一样长，如上图，短的链表遍历完后，继续遍历长的链表即可。更多思路参考一下代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\")// ListNode 链表type ListNode struct &#123; Val int Next *ListNode&#125;func main() &#123; //nums := []int&#123;1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1&#125; nums := []int&#123;9, 8, 5&#125; // 根据数组生成第一个链表 list1 := generateLinkList(nums) nums = []int&#123;5, 6, 4&#125; // 根据数组生成第二个链表 list2 := generateLinkList(nums) // 两数相加的结果（链表） numbers := addTwoNumbers(list1, list2) // 遍历打印结果（链表） for numbers != nil &#123; fmt.Print(\"-&gt;\", numbers.Val) numbers = numbers.Next &#125;&#125;// 将两个数相加func addTwoNumbers(list1 *ListNode, list2 *ListNode) *ListNode &#123; // 创建一个空的节点 resultList := &amp;ListNode&#123;&#125; currentList := resultList sum := 0 for list1 != nil || list2 != nil || sum != 0 &#123; // 获取第一个链表上的值 if list1 != nil &#123; sum += list1.Val list1 = list1.Next &#125; // 获取第二个链表上的值 if list2 != nil &#123; sum += list2.Val list2 = list2.Next &#125; // 将两数之和取模后存放到链表中的一个元素上 currentList.Next = &amp;ListNode&#123;Val: sum % 10&#125; // 移动链表 currentList = currentList.Next // 记录是否有进位的情况 sum = sum / 10 &#125; return resultList.Next&#125;// 根据数组生成链表func generateLinkList(nums []int) *ListNode &#123; if len(nums) == 0 &#123; return nil &#125; listNode := make([]ListNode, len(nums)) listNode[0] = ListNode&#123;nums[0], nil&#125; for i := 1; i &lt; len(nums); i++ &#123; listNode[i] = ListNode&#123;nums[i], nil&#125; listNode[i-1].Next = &amp;listNode[i] &#125; return &amp;listNode[0]&#125;","link":"/2019/08/31/LeetCode2-AddTwoNumbers/"},{"title":"Go语言基础-01-数组","text":"数组的内部实现 长度固定 内存空间连续，有利于计算索引，快速迭代数据 数组的元素类型相同，每个元素占用空间大小相同，方便快速计算元素的内存位置 长度是数组类型的一部分，相同类型不同长度的数组是不同的数据类型 数组的声明和初始化 指定数组长度，使用默认值「零值」初始 1var array = [3] int &#123;&#125; // 数组中的元素都会被初始化为 int 类型的零值 指定数组长度，使用字面量初始化 1var array = [3] int &#123;3, 2&#125; // 字面量不够时剩下的元素初始化为零值 指定数组长度，并初始化指定的元素 1var array = [3] int &#123;1:100, 2:200&#125; // 指定的元素被初始为相应的值，其他的元素使用零值 不指定数组长度，通过字面量来计算长度 123456// 更具字面量个数计算数组的长度array1 := [...]int&#123;1, 3, 5, 7, 9, 11&#125;// 更具指定的最大元素的下标来计算数组的长度，本例子中最大元素下标为8，因此数组的长度为9// 其他的元素初始化为0array2 := [...]int&#123;1: 100, 8: 200&#125;array3 := [...]int&#123;8: 200, 1: 100, 3, 4, 3, 2, 1&#125; 注意1：初始值全部为字面量的直接按照顺序初始化，如：{1, 3, 5, 7, 9, 11} 注意2：初始值全部为指定的元素的值初始化指定元素，且不需要按照顺序写，比如 {8: 100, 1: 200} 注意3：顺序字面量和指定元素混合使用 123456// 报错：duplicate index in array literal: 2，因为指定的第二个元素已经被字面量初始化了arr1 := [...] int &#123;1: 100, 3, 4, 3, 2, 1, 2: 200&#125;// 正确写法：应该将第二个元素写在正确的顺序上arr2 := [...] int &#123;1: 100, 2: 200, 3, 4, 3, 2, 1&#125;// 下面的也是正确的写法，如果指定的元素例如 &#123;8： 200&#125; 明显是数组中的最大的索引，则可以放在任何位置arr3 := [...] int &#123;1: 100, 8: 200, 3, 4, 3, 2, 1&#125; 演示代码片段 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; // 1：声明使用默认值初始化的数组 array1 := [3]int&#123;&#125; fmt.Println(\"1: \", array1) // 2：使用字面量初始化数组 // 字面量不够时剩下的元素初始化为零值 array2 := [3]int&#123;1, 2&#125; fmt.Println(\"2: \", array2) // 3: 指定特定元素的值，其他元素默认零值 array3 := [3]int&#123;1: 10, 2: 100&#125; fmt.Println(\"3: \", array3) // 4: 更具字面量计算数组长度 array4 := [...]int&#123;1, 3, 5, 7, 9, 11&#125; fmt.Println(\"4: \", array4) // array5 := [...]int&#123;8: 200, 1: 100, 3, 4, 3, 2, 1, 2&#125; 这样也可以 array5 := [...]int&#123;1: 100, 8: 200&#125; fmt.Println(\"5: \", array5)&#125; 执行结果 除了上面使用顺序初始值序列来初始化数组，还有一种方式初始化数组，如下 12345678910111213// Currency 货币符号type Currency int// USD 美元const ( USD Currency = iota // 美元 EUR // 欧元 GBP // 英镑 RMB // 人民币)symbol := [...]string&#123;USD: \"$\", EUR: \"€\", GBP: \"￡\", RMB: \"￥\"&#125;fmt.Println(symbol) 数组的比较 如果数组的 元素类型 时可以比较的，那么数组也时可以比较的，可以使用 == 比较两个数组，只有当两个数组元素都是相等的数组才是相等的，!= 比较符号同理 注意：两个数组的类型必须相同（包括数组的长度相同）才能比较 否则会报错 invalid operation: array1 == array4 (mismatched types [3]int and [6]int) 1234567array1 := [3] int &#123;1, 2, 3&#125;array2 := [...] int &#123;1， 2， 3&#125;array3 := [3] int &#123;&#125;fmt.Println(array1==array2) // truefmt.Println(array1==array3) // falsearray4 := [...] int &#123;1, 2, 3, 4, 5&#125;fmt.Println(array1==array4) // compile error 编译报错，无法比较，两个数组不是相同的类型 使用数组访问元素，直接使用数组的索引数组内存空间是联系的，可以快速高效的访问元素 123456789101112// 创建一个数组，并初始化array1 := [...] int &#123;1, 2, 3&#125;// 修改地 2 个元素的值array1[2] = 200// 元素是指针类型array2 := [...]*int&#123;new(int), new(int)&#125;fmt.Println(array2)// 修改指针类型元素的值*array2[0] = 100*array2[1] = 200fmt.Println(*array2[1]) // 200 赋值操作Go 语言中，数组是一个值，相同类型的数组可以赋值给另一个数组 1234567// 数组的赋值操作array1 := [5]string&#123;&#125;array2 := [...]string&#123;\"Red\", \"Blue\", \"Green\", \"Yellow\", \"pink\"&#125;array1 = array2// 两个数组的元素相同fmt.Println(array1)fmt.Println(array2) 如果两个数组的长度不同，则不是相同类型的数组，赋值时会编译报错 如果数组元素时指针类型的，则赋值的时候值会赋值元素的值（地址）而不是指针指向的值 12345678array1 := [...]*string&#123;new(string), new(string), new(string)&#125;*array1[0] = \"Red\"*array1[1] = \"Blue\"*array1[2] = \"Green\"// 指针类型数组的赋值操作array2 := [3]*string&#123;&#125;array2 = array1fmt.Println(array2) 多维数组多维数组和上述的一维数组大同小异，具体不在赘述，请参考以下代码 需要注意的是可以将多维数组的其中一个维度的数组赋值给一个一维数组 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"// 多维数组func main() &#123; // 二维数组 var array1 [4][2]int fmt.Println(array1) // 使用字面量初始化 array2 := [4][2]int&#123;&#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125; fmt.Println(array2) // 初始化两个维度的指定元素的值 array3 := [4][2]int&#123;1: &#123;0: 1, 2&#125;&#125; fmt.Println(array3) ////////////////////////////////////////// // 访问数组的元素 array4 := [2][2]int&#123;&#125; array4[0][0] = 10 array4[0][1] = 20 array4[1][0] = 30 array4[1][1] = 40 fmt.Println(array4) ////////////////////////////////////////// // 赋值: 两个相同维度的数组 array5 := [2][2]int&#123;&#125; array6 := [2][2]int&#123;&#125; array6[0][0] = 10 array6[0][1] = 20 array6[1][0] = 30 array6[1][1] = 40 array5 = array6 fmt.Println(array5) // 独立的将某个维度的元素赋值给另一个元素，如下 // 将二维数组 array6 中的第二个元素中的数组 &#123;30, 40&#125; 赋值给了一维数组 array7 array7 := [2]int&#123;&#125; array7 = array6[1] fmt.Println(array7)&#125; 在函数间传递数组Go 语言中，在函数间传递参数时总是以 值 的方式传递的（值传递），如果时数组也会完整的赋值出一个数组传递给函数。 为了性能方面考虑，较好的方法时使用指针来传递数组的地址 1234567891011package main// 使用指针传递数组func main() &#123; array := [100]int&#123;&#125; foo(&amp;array)&#125;func foo(array *[100]int) &#123; // ...&#125;","link":"/2019/09/01/Golang-Basic01-Arrays/"},{"title":"LeetCode7-ReverseInteger","text":"问题描述『7.两数之和』 查看原题 中文 『难度』🟢「Easy」 思路分析通过取模将数字从地位到高位的取出放到切片中（个位上的数字位切片的第一个元素），然后遍历切片以此乘以相应个10（比如千位上的数字乘以100），注意上图中红色标出的部分，需要判断是否溢出 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"math\")// 7. 整数反转// 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。func main() &#123; result := reverse(2019) fmt.Println(result)&#125;func reverse(x int) int arr := []int&#123;&#125; i := 0 for x != 0 &#123; arr = append(arr, x%10) i++ x = x / 10 &#125; // 获取切片的长度 arrLen := len(arr) temp := 0 for i, v := range arr &#123; // num=3 表示千位数，num=2 表示百位数 num := arrLen - (i + 1) temp += v * getTens(num) &#125; // 如果不在下面的范围内则返回 0 if !(temp &gt;= math.MinInt32 &amp;&amp; temp &lt;= math.MaxInt32) &#123; return 0 &#125; return temp&#125;// 如果是千位上的数返回100，以此类推func getTens(num int) int &#123; tens := 1 for i := 0; i &lt; num; i++ &#123; tens *= 10 &#125; return tens&#125; 学习别人的解题方法只用了11行代码 1234567891011func reverse(x int) int &#123; y := 0 for x!=0 &#123; y = y*10 + x%10 if !( -(1&lt;&lt;31) &lt;= y &amp;&amp; y &lt;= (1&lt;&lt;31)-1) &#123; return 0 &#125; x /= 10 &#125; return y&#125;","link":"/2019/09/02/LeetCode7-ReverseInteger/"},{"title":"Go语言基础-02-切片","text":"切片的内部实现 可边长的序列结构 数组的元素类型相同 底层引用了数组队形 一个 slice 由 指针 长度 和 容量 构成 指针指向第一个 slice 元素对应的底层数组的元素地址（slice的第一个元素不一定是数组的第一个元素） 长度对应 slice 中元素的数目，长度不能超过容量（使用内置的 len 函数可以获取长度） 容量一般从 slice 的开始位置到底层数组的结尾位置（使用内置的 cap 函数可以获取容量） 多个 slice 可以共享底层的数据 切片的创建和初始化make 和切片字面量使用 make 创建切片 只指定切片的长度时容量等于长度 12// 创建一个字符串类型的切片，且指定长度位5，容量默认也为5slice := make([]string, 5) 指定切片的长度和容量 长度不能大于容量，否则报错 超出长度的元素切片不能访问 1slice := make([]string, 3, 5) 通过字面量创建切片注意：切片的方括号 [] 中不能指定数值，如果指定数值则创建的就是数组 声明一个长度和容量相同的切片 注意声明数组时使用的是 […] 符号，而声明切片时使用的是空的 [] 12slice1 := []string&#123;\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\"&#125;slice2 := []string&#123;10, 20, 30&#125; 使用索引创建容量和长度一样的切片, 123// 创建一个长度和容量都是 100 的切片// 初始化第 100 个元素的值为 99slice4 := []int&#123;99: 99&#125; 声明数组和声明切片的比较 声明数组时方括号中不能为空，如果通过初始值自动设置长度则需要在方括号中写入三个点 […] 声明切片时方括号必须为空 12array := [...] int &#123;10, 20, 30&#125;slice := [] int &#123;\"abc\", \"def\", \"ghi\"&#125; nil 切片和空切片 创建一个值为 nil 的切片 1var slice []int 创建 空切片 1234// 使用 make 创建空的整形切片slice := make([]int, 0)// 使用切片字面量创建空的整形切片slice := [] int &#123;&#125; 使用切片检索和赋值检索切片中的元素和检索数组中的元素方式一样 1234// 创建一个切片并初始化slice := [] int &#123;10, 20, 30, 40, 50&#125;// 修改第二个元素的值为 200slice[1] = 200 使用切片创建切片 12345// 创建一个整形索引slice := [] int &#123;10, 20, 30, 40, 50&#125;// 创建一个新的切片，基于 slice 切片// 长度为 2 个元素，容量为4 个元素newSlice := slice[1:3] 计算切片的长度和容量 123对于底层数组容量是 k 的切片 slice[i:j] 来说长度：j - i容量：k - i 两个切片共享一个底层数组时，如果一个切片修改了数组中的值，另一个切片也会被修改 12345678// 创建一个整形索引slice := [] int &#123;10, 20, 30, 40, 50&#125;// 创建一个新的切片，基于 slice 切片// 长度为 2 个元素，容量为4 个元素newSlice := slice[1:3]// 修改 newSlice 索引为1的元素// 同时也修改了原来的 slice 的所有为 2 的元素newSlice[1] = 35 切片增长使用 append 向切片中追加元素 1234567// 创建一个整形切片slice := [] int &#123;10, 20, 30, 40, 50&#125;// 创建一个新的切片newSlice := slice[1:3]// 使用原来的容量来分配一个新的元素// 将新元素赋值为 60newSlice = append(newSlice, 60) 因为 newSlice 在底层数组里还有 额外的容量 可用，append 操作将可用的元素合并到切片的长度，并对其赋值。 如果切片的底层数组没有足够的空间可以使用，append 函数会创建一个新的底层数组，将被用于的现有值复制到新的数组中，再追加新值。 12345// 创建切片slice := [] int &#123;10, 20, 30, 40&#125;// 想切片中追加新元素// 将新元素赋值为 50newSlice := append(slice, 50) append 函数会智能的处理底层数组的长度，切片的容量小于 1000 时，总是成倍的增加容量，超过 1000 后，容量的增长因子会设为 1.25，即每次增长 25% 的容量 创建切片时的3个索引在创建切片时，还有第三个索引可以使用。第三个索引是用来控制新切片的容量来限制容量，在明确所需的切片大致容量时，指定一个容量能够避免切片扩容带来的性能损耗。 设置切片的长度和容量1234567891011// 指定切片的长度为 5，容量为 10// 只有在使用的长度超过 容量时 切片才会去扩容slice1 := make([]int, 5, 10)slice1 = append(slice1, 10)slice1 = append(slice1, 20)slice1 = append(slice1, 30)slice1 = append(slice1, 40)slice1 = append(slice1, 50)slice1 = append(slice1, 60)slice1 = append(slice1, 70)fmt.Println(slice1) 设置的容量超过已有容量时报错123456789// 创建字符串切片，长度和容量都是 5source := []string&#123;\"Apple\", \"Orange\", \"Plum\", \"Banana\", \"Grape\"&#125;// 基于上面的切片，创建一个新的切片// 切片的长度为 3-2=1// 切片的容量为 6-2=4// 切片的起始位置是上一个切片索引为 2 的元素「Plum」开始，最大可用的容量为 3 个// 所以企图设置容量为 4 时，会报错: runtime error: slice bounds out of rangeslice := source[2:3:6]fmt.Println(slice) 设置长度和容量一样的好处","link":"/2019/09/03/Golang-Basic02-Slice/"}],"tags":[{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"First","slug":"First","link":"/tags/First/"},{"name":"Goroutine","slug":"Goroutine","link":"/tags/Goroutine/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"DEMO","slug":"DEMO","link":"/categories/DEMO/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"}]}