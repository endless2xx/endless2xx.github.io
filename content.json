{"pages":[{"title":"关于本站","text":"About Me12345// 想好了再写type Coder struct &#123; name string email string&#125; TODO List存疑的问题，先再此处记录 问题 存档日期 解决日期 解决方案 测试 2019年8月31日 2019年8月31日 ✅测试 更新记录 2019年8月10日 周六 开启本博客，使用 Hexo 生成，基于 Minos 主题","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"归档","text":"","link":"/achives/index.html"},{"title":"画廊","text":"","link":"/music/index.html"},{"title":"标签们","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to my personal blog, have enjoy !测试代码块： 123456789package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"Hello World\")&#125;","link":"/2019/08/10/HelloWorld/"},{"title":"Go語言并发入门1-goroutine","text":"并发与并行进程与线程操作系统是在 物理处理器 上调度线程来执行，而 Go 语言在运行时，会在 逻辑处理器 上调度 goroutine(协程) 来运行，每个逻辑处理器都分别绑定到一个操作系统线程。从 Go 1.5 版本开始，Go 语言默认会为每个可用的物理处理器分配一个逻辑处理器，这些逻辑处理器会用于执行所有被创建的 goroutine。而在 1.5 版本之前，默认给整个应用程序只分配一个逻辑处理器。 如下图所示，一个逻辑处理器（如P0）被绑定到了操作系统线程（M2）上，该逻辑处理器对应一个本地的 运行队列 每一次创建新的 goroutine 都会本分配到运行队列上，二逻辑处理器则是从该队列上调度 goroutine 来执行。 如果运行的 goroutine 需要执行一个阻塞的操作（比如打开文件）时，线程 和 goroutine 会从 逻辑处理器 上分离开（如下图右侧图所示），该线程（M2）会继续阻塞，而此时的调度器会为逻辑处理器创建一个新的 线程 并绑定在该逻辑处理器上，之后，该逻辑处理器可以继续从运行队列中选择 goroutine 来执行。一旦被阻塞的操作执行完成并返回，对应的 goroutine 会被放回到本地运行队列，而之前的线程会被保存好，以便可以继续使用。 调度器对可以创建的逻辑处理器的数量没有限制，但是语言运行时默认限制每个程序最多创建 10 000 个线程（每个逻辑处理器都会绑定一个系统线程，所以创建一个逻辑处理器就需要创建一个系统线程）。该限制可以可以通过调用 runtime/debuger 包中的 SetMaxThreads 方法来设置。 并发和并行的区别并行： 不同的代码同时在 不同的处理器 上执行，需要更多的硬件资源，比如多核处理器 并发： 不同的代码在同 一个处理器 上执行，需要较少的硬件资源，单核处理器就可以处理 Go 语言的设计理念是『使用较少的资源做更多的事』。 当有多个逻辑处理器可以使用时，Go 语言的调度器会将 goroutine 平均分配到每个逻辑处理器，这样 goroutine 就会在不同的线程上执行。 goroutine下面通过一个例子深入理解调度器的行为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"runtime\" \"sync\")// 演示如何创建 goroutine// 以及调度器的行为func main() &#123; // 分配一个逻辑处理器给调度器 // 函数 GOMAXPROCS 允许程序更改调度器可以使用的逻辑处理器的数量 runtime.GOMAXPROCS(1) // wg 用来等待程序完成 // 计数加2，表示等待两个 goroutine var wg sync.WaitGroup wg.Add(2) fmt.Println(\"Start Goroutines\") // 声明一个匿名函数，并创建一个 goroutine go func() &#123; // 在函数退出时调用 Done 来通知 main 函数工作已经完成 defer wg.Done() // 打印字母表 3 次 for count := 0; count &lt; 3; count++ &#123; for char := 'a'; char &lt; 'a'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() fmt.Printf(\"\\n\") // 声明一个匿名函数，并创建第二个 goroutine go func() &#123; // 同上 defer wg.Done() for count := 0; count &lt; 3; count++ &#123; for char := 'A'; char &lt; 'A'+26; char++ &#123; fmt.Printf(\"%c \", char) &#125; fmt.Printf(\"\\n\") &#125; &#125;() // 等待 goroutine 结束 fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"\\nTerminating Program\")&#125; 执行结果： 疑问？此处为什么是先打印 大写字母 而不是先打印 小写字母 ？？？ TODO-1: 暂时存疑，后面研究一下单独写一篇博客来记录 此处，书中有一句解释： 这里说的第一个 goroutine 完成时间太短的意识是 大写字母 和 小写字母 没有交叉打印的原因。下面的列子则演示了两个 goroutine 相互交叉打印的情况： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"runtime\" \"sync\")var wg sync.WaitGroupfunc main() &#123; runtime.GOMAXPROCS(1) wg.Add(2) fmt.Println(\"Create Goroutines\") go printPrime(\"A\") go printPrime(\"B\") fmt.Println(\"Waiting To Finish\") wg.Wait() fmt.Println(\"Terminating Program\")&#125;func printPrime(prefix string) &#123; defer wg.Done()next: for outer := 2; outer &lt; 5000; outer++ &#123; for inner := 2; inner &lt; outer; inner++ &#123; if outer%inner == 0 &#123; continue next &#125; &#125; fmt.Printf(\"%s: %d \\n\", prefix, outer) &#125; fmt.Println(\"Completed\", prefix)&#125;","link":"/2019/08/11/Go語言并发入门1--goroutine/"},{"title":"LeetCode848-字母移位","text":"问题描述 『848.字母移位』 查看原题 『中文』 『难度』🟡「Medium」 代码12345678910111213141516171819202122package mainimport \"fmt\"var letters = []byte&#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'&#125;func main() &#123; shifts := []int&#123;3, 5, 9&#125; S := shiftingLetters(\"abc\", shifts) fmt.Println(S)&#125;func shiftingLetters(S string, shifts []int) string &#123; bs := []byte(S) move := 0 for i := len(shifts) - 1; i &gt;= 0; i-- &#123; // 需要移动的位数，因为字母表是循环的，所以对26取模就是移动的次数 move += (shifts[i] % 26) bs[i] = letters[(int(bs[i]-'a')+move)%26] &#125; return string(bs)&#125;","link":"/2019/08/18/LeetCode848-ShiftingLetters/"},{"title":"LeetCode1-TwoSum","text":"问题描述『1.两数之和』 查看原题 中文 『难度』🟢「Easy」 思路分析假设遍历数组的第一个元素是2，而 target = 9，所以可以得知另一个值是 9-2 = 7，然后去判断数组中是否有 7 这个元素，以此类推。 代码123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; nums := []int&#123;2, 3, 4&#125; target := 6 result := twoSum(nums, target) fmt.Println(result)&#125;// 计算两数之和func twoSum(nums []int, target int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; // 获得另一个数 another := target - nums[i] for j := i + 1; j &lt; len(nums); j++ &#123; if nums[j] == another &#123; result := []int&#123;i, j&#125; return result &#125; &#125; &#125; return nil&#125;","link":"/2019/08/29/LeetCode1-TwoSum/"},{"title":"LeetCode2-AddTwoNumbers","text":"问题描述『2.两数相加』 查看原题 中文 『难度』🟡「Medium」 思路分析错误的思路本人一开始的想法就是将两个链表都转换成数字，然后将两个数字相加，再将得到的和转换成链表。这样的想法是不周全的，没有考虑到如果链表特别的长，数值会越界的情况，如下图，这是本人第一次提交的结果，可以看到输入的第一个链表特别长，所以计算的时候数值越界出现错误的结果 正确的思路首先，请注意，链表中的元素从左到右是从 个位数 到 高位数 递增的，及第一个数是个位数，所以应该是遍历链表，将两个同一位上的数值相加，如果有进位记录下来，还需要考虑两个链表不一样长，如上图，短的链表遍历完后，继续遍历长的链表即可。更多思路参考一下代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\")// ListNode 链表type ListNode struct &#123; Val int Next *ListNode&#125;func main() &#123; //nums := []int&#123;1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1&#125; nums := []int&#123;9, 8, 5&#125; // 根据数组生成第一个链表 list1 := generateLinkList(nums) nums = []int&#123;5, 6, 4&#125; // 根据数组生成第二个链表 list2 := generateLinkList(nums) // 两数相加的结果（链表） numbers := addTwoNumbers(list1, list2) // 遍历打印结果（链表） for numbers != nil &#123; fmt.Print(\"-&gt;\", numbers.Val) numbers = numbers.Next &#125;&#125;// 将两个数相加func addTwoNumbers(list1 *ListNode, list2 *ListNode) *ListNode &#123; // 创建一个空的节点 resultList := &amp;ListNode&#123;&#125; currentList := resultList sum := 0 for list1 != nil || list2 != nil || sum != 0 &#123; // 获取第一个链表上的值 if list1 != nil &#123; sum += list1.Val list1 = list1.Next &#125; // 获取第二个链表上的值 if list2 != nil &#123; sum += list2.Val list2 = list2.Next &#125; // 将两数之和取模后存放到链表中的一个元素上 currentList.Next = &amp;ListNode&#123;Val: sum % 10&#125; // 移动链表 currentList = currentList.Next // 记录是否有进位的情况 sum = sum / 10 &#125; return resultList.Next&#125;// 根据数组生成链表func generateLinkList(nums []int) *ListNode &#123; if len(nums) == 0 &#123; return nil &#125; listNode := make([]ListNode, len(nums)) listNode[0] = ListNode&#123;nums[0], nil&#125; for i := 1; i &lt; len(nums); i++ &#123; listNode[i] = ListNode&#123;nums[i], nil&#125; listNode[i-1].Next = &amp;listNode[i] &#125; return &amp;listNode[0]&#125;","link":"/2019/08/31/LeetCode2-AddTwoNumbers/"}],"tags":[{"name":"First","slug":"First","link":"/tags/First/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Goroutine","slug":"Goroutine","link":"/tags/Goroutine/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[{"name":"DEMO","slug":"DEMO","link":"/categories/DEMO/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}